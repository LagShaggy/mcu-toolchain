\chapter{Implementation}\label{imp.ch}

In this section, the general setup of the environment is described. The final container is made available at~\cite{myba}

\section{Work Environment - Docker container}\label{envsetup.ch}
To provide a portable environment where source code, different tools, and toolchains can be placed, a docker container was created. The main advantages of containers are portability and ease of replication. Tools such as Buildroot and QEMU are all available on Linux. Furthermore, containers provide the additional capability to automate large parts of the compilation processes through shell scripts, and potentially out sourcing expensive compilation, in the absence of capable local hardware, to the cloud. By using a Linux OS to run most of the tasks for this thesis, it enforces the claims made in section~\ref{proposal.ch}, by demonstrating its functionalities and portability.

To build a Docker container, a Dockerfile serves as a template, which is then built into an image and run. The official Ubuntu 20.04 Long Time Support (LTS) base image lays the foundation. This provides a solid OS with many tools that facilitate acquiring packages with the included packet manager \code{apt-get}. 

To install dependencies the \code{apt-get} command is run, followed by the package that we want to install. A set of basic tools are required for working on a CLI inside the container, a collection of the most common and broadly used utilities are shown in Listing \ref{basic-util}. We use \code{git} and \code{wget} to acquire Git repositories and files from the internet, \code{nano} a CLI text editor for \code{.config} files, and compressing and decompressing utility, all of which are seen in Listing~\ref{basic-util}. Any scripts that are displayed, unless specifically stated otherwise, are executed in the \code{bash} shell.

\begin{lstlisting}[style=SH, caption=Installing basic utility, label=basic-util, float, floatplacement=H]
apt-get install -y git \
wget \
bc \
nano \
curl \
cpio \
unzip \
rsync
\end{lstlisting}

To be able to cross-compile source code to architecture-specific binaries, we require further packages, all of which are available on Ubuntu's package manager \code{apt-get}. Among these are dependencies that the codebases of Linux, Buildroot and $\mu$Clinux require. These tools are seen in Listing~\ref{toolchain-util}.

\begin{lstlisting}[style=SH, caption=Installing toolchains and dependencies, label=toolchain-util, float, floatplacement=H]
apt-get install -y gcc \
binutils-arm-none-eabi \
make \
gcc-arm-none-eabi \
gcc-arm-linux-gnueabihf \
gcc-arm-linux-gnueabi \
libncurses-dev \
libncurses5-dev \
flex \
bison \
openssl \
libssl-dev \
dkms \
perl \
libelf-dev \
libudev-dev \
libpci-dev \
libiberty-dev \
autoconf \
lzop 
\end{lstlisting}

Lastly, we need to install qemu for ARM devices, this is seen in Listing \ref{lst:qemu-system-arm}. The \code{printf} statement allows us to answer prompted questions that are posed upon installation. The \code{8} answers question concerning location, which maps to Europe, the \code{7} to the city, in our case we chose Berlin.

\begin{lstlisting}[style=SH, caption=Installing QEMU in the container, label=lst:qemu-system-arm]
printf 'y\n8\n7\n' | apt-get install -y qemu-system-arm
\end{lstlisting}

\subsection{Downloading and setting up $\mu$Clinux}

Since the original $\mu$Clinux is not maintained anymore, the task of finding an entity that has maintained a $\mu$Clinux fork was a daunting task. In section \ref{uclinux.ch} we established our choice, a distribution maintained by Emcraft. In Listing~\ref{lst:uClinuxsetup} all dependencies are downloaded for it.

\begin{lstlisting}[style=SH, caption=Downloading $\mu$Clinux into the container and setting up its special toolchain, label=lst:uClinuxsetup, float, floatplacement=H]
wget https://sourcery.mentor.com\
/GNUToolchain/package6503/public/
arm-uclinuxeabi/\
arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2
tar -xf arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2
rm -d arm-2010q1-189-arm-uclinuxeabi-i686-pc-linux-gnu.tar.bz2
export PATH=/workdir/arm-2010q1/bin:$PATH

dpkg --add-architecture i386
apt-get update && apt-get upgrade -y
apt-get install	libc6:i386

#download emcraft uClinux 
git clone https://github.com/EmcraftSystems/linux-emcraft.git
git clone https://github.com/EmcraftSystems/u-boot.git

#fixing filename so compiles work
cp /workdir/linux-emcraft/initramfs-list-min.stub \
/workdir/linux-emcraft/initramfs-list-min
cp /workdir/linux-emcraft/arch/arm/kernel/vmlinux.lds.S.good \
/workdir/linux-emcraft/arch/arm/kernel/vmlinux.lds.S
\end{lstlisting}

Both U-Boot and Buildroot were cloned using \code{git}, the commands are shown in Listing~\ref{lst:clone}.
\begin{lstlisting}[style=SH, caption={Cloning Buildroot and U-Boot}\label{lst:clone}, float, floatplacement=H]
git clone https://github.com/buildroot/buildroot.git
git clone https://source.denx.de/u-boot/u-boot.git
\end{lstlisting}

\section{Sample Code}
To establish a baseline with less complex code compared to the massive source code repository of the Linux kernel, that can fully be understood, a collection of sample code was found~\cite{sample-code}. These three code snippets, in combination with QEMU as an emulator for the target platform, will provide a controlled environment, in which it is easier to verify if the compilation was successful and correct, and if the binaries work on the target platform, or if it was correctly linked. Having such a fallback option saves time and power, and provides a solid foundation for the complex processes that occur during cross-compilation. 

\code{notmain.c}, as seen in Listing~\ref{notmain.c}, written in the C programming language represents the kernel, which contains the basic loop, with the task of printing the numbers 0 to 7 onto some Universal Asynchronous Receiver-Transmitter (UART). Listing~\ref{flash.ld} and~\ref{flash.s}, are the corresponding linker and assembler file, respectively. Theoretically, the output, after compilation should look something like this:

\code{01234567}

\begin{lstlisting}[style=CEE, caption={notmain.c}\label{notmain.c}, float, floatplacement=H]
void PUT32 ( unsigned int, unsigned int );
#define UART0BASE 0x4000C000
int notmain ( void )
{
    unsigned int rx;
    for(rx=0;rx<8;rx++)
    {
        PUT32(UART0BASE+0x00,0x30+(rx&7));
    }
    return(0);
}
\end{lstlisting}

\begin{lstlisting}[style=ASS, caption={flash.s}\label{flash.s}, float, floatplacement=H]
.thumb
.thumb_func
.global _start
_start:
stacktop: .word 0x20001000
.word reset
.word hang

.thumb_func
reset:
    bl notmain
    b hang

.thumb_func
hang:   b .

.thumb_func
.globl PUT32
PUT32:
    str r1,[r0]
    bx lr
\end{lstlisting}

\begin{lstlisting}[style=LD, caption={flash.ld}\label{flash.ld}, float, floatplacement=H]
ENTRY(_start)

MEMORY
{
    rom : ORIGIN = 0x00000000, LENGTH = 0x1000
    ram : ORIGIN = 0x20000000, LENGTH = 0x1000
}

SECTIONS
{
    .text : { *(.text*) } > rom
    .rodata : { *(.rodata*) } > rom
    .bss : { *(.bss*) } > ram
}
\end{lstlisting}

\section{FreeRTOS on STM32L4}

A baseline for the STM32L476G-EVAL MCU shown in~\ref{stm32l} was also established. We prepared sample code in the STM32QubeIDE mentioned in~\ref{stm.ch}. With a few exceptions, a guide was followed to reach this state~\cite{yttutorial}. In our case, the Light-Emitting Diode (LED) was connected to General-Purpose I/O (GPIO) pin B2. Seen in Listing \ref{lst:blinkingfunc} lines 8 and 27 had to be adapted to our specific board. The main goal of running this sample code on STM32L476G-EVAL MCU is to evaluate that the hardware is in working conditions and exclude any hardware-related problems.

The \code{main.c} function shown in Listing \ref{lst:blinkingmain}, initializes the configuration, peripherals and the kernel, starts the system clock, creates and adds two threads to the \code{Blink0*Handle}s which in turn are added to the scheduler. The OS, or middleware, used in this example is FreeRTOS.

\begin{lstlisting}[style=CEE, caption={\code{main.c}, the main function}\label{lst:blinkingmain}, float, floatplacement=H]
int main(void)
{
  /* MCU Configuration-----------------*/

  HAL_Init();

  /* Configure the system clock */
  SystemClock_Config();

/* Configure the peripherals common clocks */
  PeriphCommonClock_Config();

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_CAN1_Init();
  MX_COMP2_Init();
  MX_DAC1_Init();
  MX_FMC_Init();
  MX_I2C1_Init();
  MX_LPUART1_UART_Init();
  MX_USART1_UART_Init();
  MX_USART3_SMARTCARD_Init();
  MX_OPAMP1_Init();
  MX_SAI1_Init();
  MX_SDMMC1_SD_Init();
  MX_SPI2_Init();
  /* Init scheduler */
  osKernelInitialize();

  /* Create the thread(s) */
  /* creation of Blink01 */
  Blink01Handle = osThreadNew(StartBlink01, NULL, &Blink01_attributes);

  /* creation of Blink02 */
  Blink02Handle = osThreadNew(StartBlink02, NULL, &Blink02_attributes);

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  while (1)
  {

  }
}
\end{lstlisting}

The main idea with these functions is that they compete for CPU time, both trying to toggle the LED located at GPIO pin B2. With different back-off times, it should give an interesting lighting pattern, with which we can confirm that both threads are working concurrently.

\begin{lstlisting}[style=CEE, caption={\code{main.c} two blinking functions}\label{lst:blinkingfunc}, float, floatplacement=H]
void StartBlink01(void *argument)
{
  /* init code for USB_HOST */
  MX_USB_HOST_Init();
  /* Infinite loop */
  for(;;)
  {
	HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2);
    osDelay(500);
  }
  osThreadTerminate(NULL);
}

/* USER CODE BEGIN Header_StartBlink02 */
/**
* @brief Function implementing the Blink02 thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_StartBlink02 */
void StartBlink02(void *argument)
{
  /* Infinite loop */
  for(;;)
  {
	HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2);
    osDelay(600);
  }
  osThreadTerminate(NULL);
}
\end{lstlisting}

